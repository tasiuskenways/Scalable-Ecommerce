package repositories

import (
	"context"
	"testing"
	"time"

	"gorm.io/gorm"
	"gorm.io/driver/sqlite"

	// Prefer testify if the project already uses it; otherwise these imports will be unused and trimmed by go vet.
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"

	"github.com/tasiuskenways/scalable-ecommerce/user-service/internal/domain/entities"
)

func newTestDB(t *testing.T) *gorm.DB {
	t.Helper()
	// Use in-memory sqlite for fast, isolated tests
	db, err := gorm.Open(sqlite.Open(":memory:"), &gorm.Config{})
	require.NoError(t, err, "failed to open in-memory sqlite")

	// Ensure schema is created for UserProfile
	require.NoError(t, db.AutoMigrate(&entities.UserProfile{}), "failed to automigrate UserProfile")

	return db
}

func seedProfile(t *testing.T, db *gorm.DB, p entities.UserProfile) entities.UserProfile {
	t.Helper()
	require.NoError(t, db.Create(&p).Error)
	return p
}

func TestProfileRepository_Create_Succeeds(t *testing.T) {
	t.Parallel()
	db := newTestDB(t)
	repo := NewProfileRepository(db)

	ctx := context.Background()
	now := time.Now()

	profile := &entities.UserProfile{
		// Adjust field names to match the actual struct definition.
		// Common fields expected: ID, UserID, FirstName, LastName, Email, CreatedAt, UpdatedAt
		// If ID is auto-generated by GORM, leave it zero-value.
		UserID:    "user-123",
		FirstName: "Ada",
		LastName:  "Lovelace",
		Email:     "ada@example.com",
		CreatedAt: now,
		UpdatedAt: now,
	}

	err := repo.Create(ctx, profile)
	require.NoError(t, err, "Create should not error")
	assert.NotZero(t, profile.ID, "Create should populate ID")

	// Verify persisted record
	var got entities.UserProfile
	require.NoError(t, db.Where("id = ?", profile.ID).First(&got).Error)
	assert.Equal(t, "Ada", got.FirstName)
	assert.Equal(t, "Lovelace", got.LastName)
	assert.Equal(t, "ada@example.com", got.Email)
	assert.Equal(t, "user-123", got.UserID)
}

func TestProfileRepository_GetByUserID_Found(t *testing.T) {
	t.Parallel()
	db := newTestDB(t)
	repo := NewProfileRepository(db)
	ctx := context.Background()

	p := seedProfile(t, db, entities.UserProfile{
		UserID:    "user-abc",
		FirstName: "Grace",
		LastName:  "Hopper",
		Email:     "grace@example.com",
	})

	got, err := repo.GetByUserID(ctx, "user-abc")
	require.NoError(t, err)
	require.NotNil(t, got)
	assert.Equal(t, p.ID, got.ID)
	assert.Equal(t, "Grace", got.FirstName)
}

func TestProfileRepository_GetByUserID_NotFoundReturnsNil(t *testing.T) {
	t.Parallel()
	db := newTestDB(t)
	repo := NewProfileRepository(db)
	ctx := context.Background()

	got, err := repo.GetByUserID(ctx, "non-existent")
	require.NoError(t, err)
	assert.Nil(t, got, "should return (nil, nil) when not found")
}

func TestProfileRepository_GetByUserID_PropagatesOtherErrors(t *testing.T) {
	t.Parallel()
	db := newTestDB(t)
	// Force non-RecordNotFound error by dropping table
	require.NoError(t, db.Migrator().DropTable(&entities.UserProfile{}))
	repo := NewProfileRepository(db)
	ctx := context.Background()

	got, err := repo.GetByUserID(ctx, "any")
	assert.Error(t, err, "should propagate errors other than record not found")
	assert.Nil(t, got)
}

func TestProfileRepository_GetByID_Found(t *testing.T) {
	t.Parallel()
	db := newTestDB(t)
	repo := NewProfileRepository(db)
	ctx := context.Background()

	p := seedProfile(t, db, entities.UserProfile{
		UserID:    "user-xyz",
		FirstName: "Linus",
		LastName:  "Torvalds",
		Email:     "linus@example.com",
	})

	got, err := repo.GetByID(ctx, p.ID)
	require.NoError(t, err)
	require.NotNil(t, got)
	assert.Equal(t, "user-xyz", got.UserID)
}

func TestProfileRepository_GetByID_NotFoundReturnsNil(t *testing.T) {
	t.Parallel()
	db := newTestDB(t)
	repo := NewProfileRepository(db)
	ctx := context.Background()

	got, err := repo.GetByID(ctx, "00000000-0000-0000-0000-000000000000")
	require.NoError(t, err)
	assert.Nil(t, got)
}

func TestProfileRepository_GetByID_PropagatesOtherErrors(t *testing.T) {
	t.Parallel()
	db := newTestDB(t)
	require.NoError(t, db.Migrator().DropTable(&entities.UserProfile{}))
	repo := NewProfileRepository(db)
	ctx := context.Background()

	got, err := repo.GetByID(ctx, "any-id")
	assert.Error(t, err)
	assert.Nil(t, got)
}

func TestProfileRepository_Update_Succeeds(t *testing.T) {
	t.Parallel()
	db := newTestDB(t)
	repo := NewProfileRepository(db)
	ctx := context.Background()

	p := seedProfile(t, db, entities.UserProfile{
		UserID:    "user-upd",
		FirstName: "Tim",
		LastName:  "Berners-Lee",
		Email:     "tim@old.example.com",
	})

	// Change fields
	p.Email = "tim@new.example.com"
	p.FirstName = "Timothy"

	err := repo.Update(ctx, &p)
	require.NoError(t, err)

	var got entities.UserProfile
	require.NoError(t, db.Where("id = ?", p.ID).First(&got).Error)
	assert.Equal(t, "Timothy", got.FirstName)
	assert.Equal(t, "tim@new.example.com", got.Email)
}

func TestProfileRepository_Update_PropagatesErrors(t *testing.T) {
	t.Parallel()
	db := newTestDB(t)
	repo := NewProfileRepository(db)
	ctx := context.Background()

	p := seedProfile(t, db, entities.UserProfile{
		UserID:    "user-upd-err",
		FirstName: "Err",
		LastName:  "Case",
		Email:     "err@example.com",
	})

	// Drop table to force save error
	require.NoError(t, db.Migrator().DropTable(&entities.UserProfile{}))

	err := repo.Update(ctx, &p)
	assert.Error(t, err, "should propagate update error when table is missing")
}

func TestProfileRepository_Delete_Succeeds(t *testing.T) {
	t.Parallel()
	db := newTestDB(t)
	repo := NewProfileRepository(db)
	ctx := context.Background()

	p := seedProfile(t, db, entities.UserProfile{
		UserID:    "user-del",
		FirstName: "Delete",
		LastName:  "Me",
		Email:     "del@example.com",
	})

	err := repo.Delete(ctx, p.ID)
	require.NoError(t, err)

	var count int64
	require.NoError(t, db.Model(&entities.UserProfile{}).Where("id = ?", p.ID).Count(&count).Error)
	assert.Equal(t, int64(0), count, "record should be deleted")
}

func TestProfileRepository_Delete_PropagatesErrors(t *testing.T) {
	t.Parallel()
	db := newTestDB(t)
	repo := NewProfileRepository(db)
	ctx := context.Background()

	p := seedProfile(t, db, entities.UserProfile{
		UserID:    "user-del-err",
		FirstName: "Drop",
		LastName:  "Table",
		Email:     "drop@example.com",
	})

	// Drop table to force delete error
	require.NoError(t, db.Migrator().DropTable(&entities.UserProfile{}))

	err := repo.Delete(ctx, p.ID)
	assert.Error(t, err)
}

func TestProfileRepository_ExistsByUserID(t *testing.T) {
	t.Parallel()
	db := newTestDB(t)
	repo := NewProfileRepository(db)
	ctx := context.Background()

	exists, err := repo.ExistsByUserID(ctx, "nobody")
	require.NoError(t, err)
	assert.False(t, exists, "should be false for non-existing user")

	_ = seedProfile(t, db, entities.UserProfile{
		UserID:    "user-exists",
		FirstName: "Existy",
		LastName:  "McExistface",
		Email:     "exists@example.com",
	})

	exists, err = repo.ExistsByUserID(ctx, "user-exists")
	require.NoError(t, err)
	assert.True(t, exists, "should be true when record exists")
}

func TestProfileRepository_ExistsByUserID_PropagatesErrors(t *testing.T) {
	t.Parallel()
	db := newTestDB(t)
	repo := NewProfileRepository(db)
	ctx := context.Background()

	// Force error
	require.NoError(t, db.Migrator().DropTable(&entities.UserProfile{}))

	exists, err := repo.ExistsByUserID(ctx, "any")
	assert.Error(t, err)
	assert.False(t, exists)
}